Analisando o código do Service Worker, identifiquei alguns pontos que podem causar um loop infinito no botão "Salvar", mantendo-o no estado de "salvando" mesmo após o envio aparentemente bem-sucedido:

### Possíveis Causas do Loop Infinito:

1. **Notificação Duplicada de Conclusão**:
   - O código envia dois eventos de notificação (`save-completed` e `form-save-completed`) com um delay de 200ms
   - Se o cliente estiver escutando ambos, pode reiniciar o estado acidentalmente

2. **Resposta Simulada sem Tratamento Adequado**:
   ```javascript
   return new Response(JSON.stringify({
     success: true,
     _offline: true,
     _pending: true,  // ← Este flag pode estar causando confusão
     id: tempId,
     tableName: tableName,
     _timestamp: Date.now()
   }), {
     status: 200,
     headers: { 'Content-Type': 'application/json' }
   });
   ```
   - O campo `_pending: true` na resposta simulada pode estar sendo interpretado como "ainda processando"

3. **Falta de Atualização do Estado após Sincronização**:
   - Quando a sincronização ocorre posteriormente, não há um evento claro indicando que a operação offline foi resolvida

4. **Problema na Estratégia de Retry**:
   - Se a função `syncPendingRequests()` falhar silenciosamente, as requisições permanecem no banco de dados e podem ser reprocessadas indefinidamente

### Soluções Recomendadas:

1. **Modificar a Resposta Offline**:
   ```javascript
   return new Response(JSON.stringify({
     success: true,
     offline: true,  // Usar apenas este flag
     tempId: tempId,
     tableName: tableName
   }), {
     status: 202,  // 202 Accepted é mais semântico para operações assíncronas
     headers: { 'Content-Type': 'application/json' }
   });
   ```

2. **Garantir Finalização Clara**:
   - Remover o segundo evento `form-save-completed` ou garantir que ele só seja enviado após confirmação real do servidor

3. **Adicionar Timeout na Sincronização**:
   ```javascript
   async function syncPendingRequests() {
     const controller = new AbortController();
     const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
     
     try {
       // ... código existente ...
     } finally {
       clearTimeout(timeoutId);
     }
   }
   ```

4. **Adicionar Logs de Depuração**:
   - Incluir logs adicionais para rastrear o ciclo completo da operação:
   ```javascript
   console.log('[SW] Iniciando processamento offline', request.method, request.url);
   console.log('[SW] Notificando cliente sobre operação offline');
   console.log('[SW] Operação offline concluída, tempId:', tempId);
   ```

5. **Verificar o Lado do Cliente**:
   - O problema pode estar na forma como o cliente está interpretando as respostas. Sugiro verificar:
   - Se o cliente está tratando corretamente respostas com `status 202`
   - Se há múltiplos listeners para os mesmos eventos
   - Se o estado "salvando" é limpo tanto para sucesso quanto para falha

### Ponto Crítico a Investigar:

O trecho mais suspeito está na resposta simulada para operações offline. A combinação de:
```javascript
success: true,
_offline: true,
_pending: true  // ← Este campo é especialmente problemático
```

Sugiro remover o `_pending: true` pois ele contradiz o `success: true`, criando ambiguidade que pode fazer o cliente continuar esperando por uma atualização que nunca virá.

### Fluxo Corrigido Recomendado:

1. Operação offline é salva no IndexedDB
2. Service Worker responde imediatamente com:
   - Status 202 (Accepted)
   - Flag `offline: true`
   - ID temporário
3. Cliente sai do estado "salvando" ao receber esta resposta
4. Quando a sincronização ocorrer posteriormente:
   - Service Worker envia notificação com o ID real
   - Cliente atualiza os registros locais se necessário

Esta abordagem evita a ambiguidade de estados que pode estar causando o loop infinito.