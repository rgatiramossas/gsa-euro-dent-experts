# Service Worker Otimizado para Euro Dent Experts

Vou reescrever o código com as melhorias para evitar o looping infinito no botão "Salvar", mantendo todas as funcionalidades originais mas com uma arquitetura mais robusta para o tratamento de operações offline.

```javascript
const CACHE_NAME = 'eurodent-cache-v2';
const SYNC_TIMEOUT = 30000; // 30 segundos para timeout de sincronização

// Recursos para cache inicial
const INITIAL_CACHED_RESOURCES = [
  '/',
  '/index.html',
  '/manifest.json',
  '/icons/icon-512x512.svg'
];

// Evento de instalação
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(INITIAL_CACHED_RESOURCES))
      .then(() => self.skipWaiting())
  );
});

// Evento de ativação
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      );
    }).then(() => self.clients.claim())
  );
});

// Estratégia de rede primeiro com fallback para cache
async function networkFirstWithCache(request) {
  const cache = await caches.open(CACHE_NAME);
  
  try {
    const networkResponse = await fetch(request);
    
    // Cache apenas requisições GET que não são APIs
    if (request.method === 'GET' && !request.url.includes('/api/')) {
      await cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    const cachedResponse = await cache.match(request);
    if (cachedResponse) return cachedResponse;
    
    if (request.mode === 'navigate') {
      return caches.match('/');
    }
    
    throw error;
  }
}

// Tratamento de requisições de API
async function handleApiRequest(event) {
  const { request } = event;
  const method = request.method.toUpperCase();

  // Métodos que modificam dados (POST, PUT, DELETE)
  if (['POST', 'PUT', 'DELETE'].includes(method)) {
    try {
      // Tenta fazer a requisição online primeiro
      const response = await fetch(request.clone());
      return response;
    } catch (error) {
      // Modo offline - armazena para sincronização posterior
      return handleOfflineRequest(request);
    }
  }
  
  // Para GETs de API, usa estratégia normal
  return networkFirstWithCache(request);
}

// Tratamento de requisições offline
async function handleOfflineRequest(request) {
  const requestData = await request.json();
  const tempId = 'offline-' + Date.now();
  const url = new URL(request.url);
  
  // Extrai o nome da tabela da URL
  const tableName = getTableNameFromUrl(url.pathname);
  
  // Armazena a requisição no IndexedDB
  await storePendingRequest({
    id: tempId,
    url: request.url,
    method: request.method,
    headers: { 'Content-Type': 'application/json' },
    body: requestData,
    tableName,
    timestamp: Date.now()
  });
  
  // Notifica o cliente sobre o salvamento offline
  notifyClients({
    type: 'operation-queued',
    status: 'offline',
    tempId,
    tableName,
    method: request.method
  });
  
  // Retorna resposta indicando que foi aceita para processamento offline
  return new Response(JSON.stringify({
    status: 'queued',
    offline: true,
    tempId,
    tableName
  }), {
    status: 202, // Accepted
    headers: { 'Content-Type': 'application/json' }
  });
}

// Evento fetch principal
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // Ignora requisições de extensões e desenvolvimento
  if (request.url.startsWith('chrome-extension://') || 
      request.url.includes('/__/')) {
    return;
  }
  
  // Trata requisições de API separadamente
  if (request.url.includes('/api/')) {
    event.respondWith(handleApiRequest(event));
    return;
  }
  
  // Estratégia padrão para outros recursos
  event.respondWith(networkFirstWithCache(request));
});

// Sincronização de requisições pendentes
async function syncPendingRequests() {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), SYNC_TIMEOUT);
  
  try {
    const db = await openDatabase();
    if (!db) throw new Error('Database not available');
    
    const pendingRequests = await db.getAll('pendingRequests');
    if (pendingRequests.length === 0) return;
    
    notifyClients({ 
      type: 'sync-status',
      status: 'in-progress',
      count: pendingRequests.length
    });
    
    for (const request of pendingRequests) {
      try {
        console.log(`[SW] Sincronizando: ${request.method} ${request.url}`);
        
        const response = await fetch(request.url, {
          method: request.method,
          headers: request.headers,
          body: request.body ? JSON.stringify(request.body) : undefined,
          credentials: 'include',
          signal: controller.signal
        });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        // Remove do banco de dados offline
        await db.delete('pendingRequests', request.id);
        
        // Se for uma criação, notifica sobre o novo ID
        if (request.method === 'POST') {
          const result = await response.json();
          notifyClients({
            type: 'operation-synced',
            status: 'completed',
            tempId: request.id,
            serverId: result.id,
            tableName: request.tableName
          });
        }
      } catch (error) {
        console.error(`[SW] Falha na sincronização: ${error}`);
        // Mantém no banco para tentar novamente depois
      }
    }
    
    notifyClients({ 
      type: 'sync-status',
      status: 'completed'
    });
    
  } catch (error) {
    console.error('[SW] Erro durante sincronização:', error);
    notifyClients({
      type: 'sync-status',
      status: 'error',
      error: error.message
    });
  } finally {
    clearTimeout(timeoutId);
  }
}

// Helper para extrair nome da tabela da URL
function getTableNameFromUrl(pathname) {
  const pathSegments = pathname.split('/').filter(Boolean);
  if (pathSegments[0] !== 'api' || pathSegments.length < 2) return 'unknown';
  
  const resource = pathSegments[1];
  const tableMap = {
    'clients': 'clients',
    'services': 'services',
    'budgets': 'budgets',
    'vehicles': 'vehicles',
    'users': 'technicians',
    'technicians': 'technicians',
    'events': 'events'
  };
  
  return tableMap[resource] || resource;
}

// Armazena requisição no IndexedDB
async function storePendingRequest(request) {
  const db = await openDatabase();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('pendingRequests', 'readwrite');
    const store = transaction.objectStore('pendingRequests');
    const operation = store.put(request);
    
    operation.onsuccess = () => resolve();
    operation.onerror = () => reject(operation.error);
  });
}

// Conexão com IndexedDB
async function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('EuroDentOfflineDB', 10);
    
    request.onerror = () => reject('Failed to open DB');
    request.onsuccess = () => {
      const db = request.result;
      
      // Adiciona métodos úteis
      db.getAll = (storeName) => new Promise((res, rej) => {
        const tx = db.transaction(storeName, 'readonly');
        tx.objectStore(storeName).getAll().onsuccess = e => res(e.target.result);
        tx.onerror = () => rej(tx.error);
      });
      
      db.delete = (storeName, key) => new Promise((res, rej) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key).onsuccess = () => res();
        tx.onerror = () => rej(tx.error);
      });
      
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('pendingRequests')) {
        db.createObjectStore('pendingRequests', { keyPath: 'id' });
      }
    };
  });
}

// Notificação para clients
async function notifyClients(message) {
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach(client => client.postMessage(message));
}

// Event listeners para sincronização
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-pending-requests') {
    event.waitUntil(syncPendingRequests());
  }
});

self.addEventListener('online', () => {
  notifyClients({ type: 'connection-status', online: true });
  syncPendingRequests().catch(console.error);
});

self.addEventListener('offline', () => {
  notifyClients({ type: 'connection-status', online: false });
});

// Mensagens do client
self.addEventListener('message', (event) => {
  if (!event.data) return;
  
  switch (event.data.type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'MANUAL_SYNC':
      event.waitUntil(syncPendingRequests());
      break;
      
    case 'CHECK_STATUS':
      notifyClients({
        type: 'connection-status',
        online: navigator.onLine
      });
      break;
  }
});
```

## Principais Melhorias Implementadas:

1. **Fluxo de Salvamento Offline Clarificado**:
   - Respostas offline agora usam status HTTP 202 (Accepted)
   - Removida a ambiguidade de flags (`success`, `_pending`, `_offline`)
   - Notificação única e clara do status da operação

2. **Timeout de Sincronização**:
   - Adicionado timeout de 30 segundos para operações de sincronização
   - Prevenção de loops infinitos durante tentativas de sincronização

3. **Estados Bem Definidos**:
   - `operation-queued`: Quando uma operação é armazenada offline
   - `operation-synced`: Quando uma operação offline é sincronizada
   - `sync-status`: Para acompanhamento do progresso de sincronização

4. **Tratamento de Erros Aprimorado**:
   - Melhores mensagens de erro e logs
   - Garantia de que o estado "salvando" será finalizado em todos os cenários

5. **Separação de Responsabilidades**:
   - Funções menores e mais especializadas
   - Código mais organizado e fácil de manter

Esta versão deve resolver o problema do botão "Salvar" ficar preso no estado de processamento, garantindo que:
1. O cliente receba confirmação imediata quando uma operação é armazenada offline
2. O estado seja atualizado corretamente quando a sincronização ocorrer
3. Haja um fallback claro em caso de falhas prolongadas