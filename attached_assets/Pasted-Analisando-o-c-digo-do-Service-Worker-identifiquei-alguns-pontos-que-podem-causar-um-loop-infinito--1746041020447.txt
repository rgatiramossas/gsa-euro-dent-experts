Analisando o código do Service Worker, identifiquei alguns pontos que podem causar um loop infinito no botão "Salvar", mantendo-o no estado de "salvando" mesmo após o envio aparentemente bem-sucedido:

Possíveis Causas do Loop Infinito:
Notificação Duplicada de Conclusão:

O código envia dois eventos de notificação (save-completed e form-save-completed) com um delay de 200ms

Se o cliente estiver escutando ambos, pode reiniciar o estado acidentalmente

Resposta Simulada sem Tratamento Adequado:

javascript
return new Response(JSON.stringify({
  success: true,
  _offline: true,
  _pending: true,  // ← Este flag pode estar causando confusão
  id: tempId,
  tableName: tableName,
  _timestamp: Date.now()
}), {
  status: 200,
  headers: { 'Content-Type': 'application/json' }
});
O campo _pending: true na resposta simulada pode estar sendo interpretado como "ainda processando"

Falta de Atualização do Estado após Sincronização:

Quando a sincronização ocorre posteriormente, não há um evento claro indicando que a operação offline foi resolvida

Problema na Estratégia de Retry:

Se a função syncPendingRequests() falhar silenciosamente, as requisições permanecem no banco de dados e podem ser reprocessadas indefinidamente

Soluções Recomendadas:
Modificar a Resposta Offline:

javascript
return new Response(JSON.stringify({
  success: true,
  offline: true,  // Usar apenas este flag
  tempId: tempId,
  tableName: tableName
}), {
  status: 202,  // 202 Accepted é mais semântico para operações assíncronas
  headers: { 'Content-Type': 'application/json' }
});
Garantir Finalização Clara:

Remover o segundo evento form-save-completed ou garantir que ele só seja enviado após confirmação real do servidor

Adicionar Timeout na Sincronização:

javascript
async function syncPendingRequests() {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
  
  try {
    // ... código existente ...
  } finally {
    clearTimeout(timeoutId);
  }
}
Adicionar Logs de Depuração:

Incluir logs adicionais para rastrear o ciclo completo da operação:

javascript
console.log('[SW] Iniciando processamento offline', request.method, request.url);
console.log('[SW] Notificando cliente sobre operação offline');
console.log('[SW] Operação offline concluída, tempId:', tempId);
Verificar o Lado do Cliente:

O problema pode estar na forma como o cliente está interpretando as respostas. Sugiro verificar:

Se o cliente está tratando corretamente respostas com status 202

Se há múltiplos listeners para os mesmos eventos

Se o estado "salvando" é limpo tanto para sucesso quanto para falha

Ponto Crítico a Investigar:
O trecho mais suspeito está na resposta simulada para operações offline. A combinação de:

javascript
success: true,
_offline: true,
_pending: true  // ← Este campo é especialmente problemático
Sugiro remover o _pending: true pois ele contradiz o success: true, criando ambiguidade que pode fazer o cliente continuar esperando por uma atualização que nunca virá.

Fluxo Corrigido Recomendado:
Operação offline é salva no IndexedDB

Service Worker responde imediatamente com:

Status 202 (Accepted)

Flag offline: true

ID temporário

Cliente sai do estado "salvando" ao receber esta resposta

Quando a sincronização ocorrer posteriormente:

Service Worker envia notificação com o ID real

Cliente atualiza os registros locais se necessário

Esta abordagem evita a ambiguidade de estados que pode estar causando o loop infinito.

poderia reescrever o codigo com essas melhorias
Service Worker Otimizado para Euro Dent Experts
Vou reescrever o código com as melhorias para evitar o looping infinito no botão "Salvar", mantendo todas as funcionalidades originais mas com uma arquitetura mais robusta para o tratamento de operações offline.

javascript
const CACHE_NAME = 'eurodent-cache-v2';
const SYNC_TIMEOUT = 30000; // 30 segundos para timeout de sincronização

// Recursos para cache inicial
const INITIAL_CACHED_RESOURCES = [
  '/',
  '/index.html',
  '/manifest.json',
  '/icons/icon-512x512.svg'
];

// Evento de instalação
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(INITIAL_CACHED_RESOURCES))
      .then(() => self.skipWaiting())
  );
});

// Evento de ativação
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      );
    }).then(() => self.clients.claim())
  );
});

// Estratégia de rede primeiro com fallback para cache
async function networkFirstWithCache(request) {
  const cache = await caches.open(CACHE_NAME);
  
  try {
    const networkResponse = await fetch(request);
    
    // Cache apenas requisições GET que não são APIs
    if (request.method === 'GET' && !request.url.includes('/api/')) {
      await cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    const cachedResponse = await cache.match(request);
    if (cachedResponse) return cachedResponse;
    
    if (request.mode === 'navigate') {
      return caches.match('/');
    }
    
    throw error;
  }
}

// Tratamento de requisições de API
async function handleApiRequest(event) {
  const { request } = event;
  const method = request.method.toUpperCase();

  // Métodos que modificam dados (POST, PUT, DELETE)
  if (['POST', 'PUT', 'DELETE'].includes(method)) {
    try {
      // Tenta fazer a requisição online primeiro
      const response = await fetch(request.clone());
      return response;
    } catch (error) {
      // Modo offline - armazena para sincronização posterior
      return handleOfflineRequest(request);
    }
  }
  
  // Para GETs de API, usa estratégia normal
  return networkFirstWithCache(request);
}

// Tratamento de requisições offline
async function handleOfflineRequest(request) {
  const requestData = await request.json();
  const tempId = 'offline-' + Date.now();
  const url = new URL(request.url);
  
  // Extrai o nome da tabela da URL
  const tableName = getTableNameFromUrl(url.pathname);
  
  // Armazena a requisição no IndexedDB
  await storePendingRequest({
    id: tempId,
    url: request.url,
    method: request.method,
    headers: { 'Content-Type': 'application/json' },
    body: requestData,
    tableName,
    timestamp: Date.now()
  });
  
  // Notifica o cliente sobre o salvamento offline
  notifyClients({
    type: 'operation-queued',
    status: 'offline',
    tempId,
    tableName,
    method: request.method
  });
  
  // Retorna resposta indicando que foi aceita para processamento offline
  return new Response(JSON.stringify({
    status: 'queued',
    offline: true,
    tempId,
    tableName
  }), {
    status: 202, // Accepted
    headers: { 'Content-Type': 'application/json' }
  });
}

// Evento fetch principal
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // Ignora requisições de extensões e desenvolvimento
  if (request.url.startsWith('chrome-extension://') || 
      request.url.includes('/__/')) {
    return;
  }
  
  // Trata requisições de API separadamente
  if (request.url.includes('/api/')) {
    event.respondWith(handleApiRequest(event));
    return;
  }
  
  // Estratégia padrão para outros recursos
  event.respondWith(networkFirstWithCache(request));
});

// Sincronização de requisições pendentes
async function syncPendingRequests() {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), SYNC_TIMEOUT);
  
  try {
    const db = await openDatabase();
    if (!db) throw new Error('Database not available');
    
    const pendingRequests = await db.getAll('pendingRequests');
    if (pendingRequests.length === 0) return;
    
    notifyClients({ 
      type: 'sync-status',
      status: 'in-progress',
      count: pendingRequests.length
    });
    
    for (const request of pendingRequests) {
      try {
        console.log(`[SW] Sincronizando: ${request.method} ${request.url}`);
        
        const response = await fetch(request.url, {
          method: request.method,
          headers: request.headers,
          body: request.body ? JSON.stringify(request.body) : undefined,
          credentials: 'include',
          signal: controller.signal
        });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        // Remove do banco de dados offline
        await db.delete('pendingRequests', request.id);
        
        // Se for uma criação, notifica sobre o novo ID
        if (request.method === 'POST') {
          const result = await response.json();
          notifyClients({
            type: 'operation-synced',
            status: 'completed',
            tempId: request.id,
            serverId: result.id,
            tableName: request.tableName
          });
        }
      } catch (error) {
        console.error(`[SW] Falha na sincronização: ${error}`);
        // Mantém no banco para tentar novamente depois
      }
    }
    
    notifyClients({ 
      type: 'sync-status',
      status: 'completed'
    });
    
  } catch (error) {
    console.error('[SW] Erro durante sincronização:', error);
    notifyClients({
      type: 'sync-status',
      status: 'error',
      error: error.message
    });
  } finally {
    clearTimeout(timeoutId);
  }
}

// Helper para extrair nome da tabela da URL
function getTableNameFromUrl(pathname) {
  const pathSegments = pathname.split('/').filter(Boolean);
  if (pathSegments[0] !== 'api' || pathSegments.length < 2) return 'unknown';
  
  const resource = pathSegments[1];
  const tableMap = {
    'clients': 'clients',
    'services': 'services',
    'budgets': 'budgets',
    'vehicles': 'vehicles',
    'users': 'technicians',
    'technicians': 'technicians',
    'events': 'events'
  };
  
  return tableMap[resource] || resource;
}

// Armazena requisição no IndexedDB
async function storePendingRequest(request) {
  const db = await openDatabase();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('pendingRequests', 'readwrite');
    const store = transaction.objectStore('pendingRequests');
    const operation = store.put(request);
    
    operation.onsuccess = () => resolve();
    operation.onerror = () => reject(operation.error);
  });
}

// Conexão com IndexedDB
async function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('EuroDentOfflineDB', 10);
    
    request.onerror = () => reject('Failed to open DB');
    request.onsuccess = () => {
      const db = request.result;
      
      // Adiciona métodos úteis
      db.getAll = (storeName) => new Promise((res, rej) => {
        const tx = db.transaction(storeName, 'readonly');
        tx.objectStore(storeName).getAll().onsuccess = e => res(e.target.result);
        tx.onerror = () => rej(tx.error);
      });
      
      db.delete = (storeName, key) => new Promise((res, rej) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key).onsuccess = () => res();
        tx.onerror = () => rej(tx.error);
      });
      
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('pendingRequests')) {
        db.createObjectStore('pendingRequests', { keyPath: 'id' });
      }
    };
  });
}

// Notificação para clients
async function notifyClients(message) {
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach(client => client.postMessage(message));
}

// Event listeners para sincronização
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-pending-requests') {
    event.waitUntil(syncPendingRequests());
  }
});

self.addEventListener('online', () => {
  notifyClients({ type: 'connection-status', online: true });
  syncPendingRequests().catch(console.error);
});

self.addEventListener('offline', () => {
  notifyClients({ type: 'connection-status', online: false });
});

// Mensagens do client
self.addEventListener('message', (event) => {
  if (!event.data) return;
  
  switch (event.data.type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'MANUAL_SYNC':
      event.waitUntil(syncPendingRequests());
      break;
      
    case 'CHECK_STATUS':
      notifyClients({
        type: 'connection-status',
        online: navigator.onLine
      });
      break;
  }
});
Principais Melhorias Implementadas:
Fluxo de Salvamento Offline Clarificado:

Respostas offline agora usam status HTTP 202 (Accepted)

Removida a ambiguidade de flags (success, _pending, _offline)

Notificação única e clara do status da operação

Timeout de Sincronização:

Adicionado timeout de 30 segundos para operações de sincronização

Prevenção de loops infinitos durante tentativas de sincronização

Estados Bem Definidos:

operation-queued: Quando uma operação é armazenada offline

operation-synced: Quando uma operação offline é sincronizada

sync-status: Para acompanhamento do progresso de sincronização

Tratamento de Erros Aprimorado:

Melhores mensagens de erro e logs

Garantia de que o estado "salvando" será finalizado em todos os cenários

Separação de Responsabilidades:

Funções menores e mais especializadas

Código mais organizado e fácil de manter

Esta versão deve resolver o problema do botão "Salvar" ficar preso no estado de processamento, garantindo que:

O cliente receba confirmação imediata quando uma operação é armazenada offline

O estado seja atualizado corretamente quando a sincronização ocorrer

Haja um fallback claro em caso de falhas prolongadas