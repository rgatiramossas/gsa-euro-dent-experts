import React, { useState } from "react";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Button } from "@/components/ui/button";
import { useTranslation } from "react-i18next";

// Interface simplificada - não exige 'value' como parâmetro
interface LocationSelectorProps {
  onLocationChange: (address: string, latitude: number | null, longitude: number | null) => void;
  initialAddress?: string;
  initialLatitude?: number | null;
  initialLongitude?: number | null;
}

export function LocationSelector({ 
  onLocationChange, 
  initialAddress = "", 
  initialLatitude = null, 
  initialLongitude = null 
}: LocationSelectorProps) {
  const { t } = useTranslation();
  const [address, setAddress] = useState(initialAddress);
  const [latitude, setLatitude] = useState<number | null>(initialLatitude);
  const [longitude, setLongitude] = useState<number | null>(initialLongitude);
  const [isGettingLocation, setIsGettingLocation] = useState(false);
  const [locationError, setLocationError] = useState<string | null>(null);

  // Handler para alterações no endereço
  const handleAddressChange = (newAddress: string) => {
    setAddress(newAddress);
    onLocationChange(newAddress, latitude, longitude);
  };

  // Obter localização atual
  const getCurrentLocation = () => {
    setIsGettingLocation(true);
    setLocationError(null);

    if (!navigator.geolocation) {
      setLocationError(t("location.browserNotSupported", "Geolocalização não é suportada pelo seu navegador"));
      setIsGettingLocation(false);
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (position) => {
        try {
          const newLatitude = position.coords.latitude;
          const newLongitude = position.coords.longitude;
          
          console.log(`Localização obtida: ${newLatitude}, ${newLongitude}`);
          
          // Tentar obter o endereço usando a API Nominatim (OpenStreetMap)
          let endereco = "";
          try {
            const response = await fetch(
              `https://nominatim.openstreetmap.org/reverse?format=json&lat=${newLatitude}&lon=${newLongitude}&zoom=18&addressdetails=1`,
              { headers: { 'Accept-Language': 'pt-BR,pt;q=0.9' } }
            );
            const data = await response.json();
            
            if (data && data.display_name) {
              endereco = data.display_name;
              console.log("Endereço obtido:", endereco);
            } else {
              // Caso não consigamos obter o endereço, usar coordenadas
              endereco = `${t("location.coordinates", "Localização")}: ${newLatitude.toFixed(6)}, ${newLongitude.toFixed(6)}`;
              console.log("Endereço não encontrado, usando coordenadas");
            }
          } catch (error) {
            console.error("Erro ao obter endereço:", error);
            endereco = `${t("location.coordinates", "Localização")}: ${newLatitude.toFixed(6)}, ${newLongitude.toFixed(6)}`;
          }
          
          // Atualizar estado local
          setLatitude(newLatitude);
          setLongitude(newLongitude);
          setAddress(endereco);
          
          // Notificar componente pai
          onLocationChange(endereco, newLatitude, newLongitude);
        } catch (error) {
          console.error("Erro ao processar localização:", error);
          setLocationError(t("location.processingError", "Erro ao processar dados de localização"));
        } finally {
          setIsGettingLocation(false);
        }
      },
      (error) => {
        let errorMessage;
        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = t("location.permissionDenied", "Permissão para geolocalização negada pelo usuário");
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = t("location.unavailable", "Informações de localização indisponíveis");
            break;
          case error.TIMEOUT:
            errorMessage = t("location.timeout", "Tempo esgotado para obter localização");
            break;
          default:
            errorMessage = t("location.unknownError", "Erro desconhecido ao obter localização");
        }
        setLocationError(errorMessage);
        setIsGettingLocation(false);
      }
    );
  };

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="address">{t("services.address", "Endereço")}</Label>
        <Input
          id="address"
          value={address}
          onChange={(e) => handleAddressChange(e.target.value)}
          placeholder={t("location.addressPlaceholder", "Digite o endereço completo")}
          className="mt-1"
        />
        {latitude && longitude && (
          <p className="text-xs text-muted-foreground mt-1">
            {t("location.coordinatesDetected", "Coordenadas detectadas")}
          </p>
        )}
      </div>
      
      <div>
        <Button
          type="button"
          variant="outline"
          className="w-full mt-1 bg-gray-50 hover:bg-gray-100"
          onClick={getCurrentLocation}
          disabled={isGettingLocation}
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-500 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
          {isGettingLocation ? t("location.getting", "Obtendo Localização...") : t("location.getCurrent", "Obter Localização Atual")}
        </Button>
        {locationError && (
          <p className="text-sm text-red-500 mt-1">{locationError}</p>
        )}
      </div>
    </div>
  );
}